// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    #[prost(int64, required, tag = "1")]
    pub block_height: i64,
    #[prost(string, required, tag = "2")]
    pub block_timestamp: ::prost::alloc::string::String,
    #[prost(string, required, tag = "3")]
    pub tx_type: ::prost::alloc::string::String,
    #[prost(uint64, required, tag = "4")]
    pub tx_version: u64,
    #[prost(string, required, tag = "5")]
    pub tx_hash: ::prost::alloc::string::String,
    #[prost(string, required, tag = "6")]
    pub state_change_hash: ::prost::alloc::string::String,
    #[prost(string, required, tag = "7")]
    pub event_root_hash: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "8")]
    pub state_checkpoint_hash: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, required, tag = "9")]
    pub gas_used: u64,
    #[prost(bool, required, tag = "10")]
    pub success: bool,
    #[prost(string, optional, tag = "11")]
    pub vm_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "12")]
    pub accumulator_root_hash: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "13")]
    pub sequence_number: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "14")]
    pub max_gas_amount: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "15")]
    pub sender: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "16")]
    pub num_events: ::core::option::Option<u64>,
    #[prost(message, required, tag = "17")]
    pub num_changes: transaction::ChangesAggregate,
    #[prost(string, optional, tag = "18")]
    pub expiration_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "19")]
    pub payload: ::core::option::Option<transaction::Payload>,
    #[prost(uint64, optional, tag = "20")]
    pub gas_unit_price: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "21")]
    pub payload_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, required, tag = "22")]
    pub block_unixtimestamp: super::common::UnixTimestamp,
    #[prost(message, optional, tag = "23")]
    pub expiration_unixtimestamp: ::core::option::Option<super::common::UnixTimestamp>,
    #[prost(uint64, optional, tag = "24")]
    pub num_signatures: ::core::option::Option<u64>,
}
/// Nested message and enum types in `Transaction`.
pub mod transaction {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChangesAggregate {
        #[prost(uint64, required, tag = "1")]
        pub total: u64,
        #[prost(uint64, required, tag = "2")]
        pub delete_module: u64,
        #[prost(uint64, required, tag = "3")]
        pub delete_resource: u64,
        #[prost(uint64, required, tag = "4")]
        pub delete_table_item: u64,
        #[prost(uint64, required, tag = "5")]
        pub write_module: u64,
        #[prost(uint64, required, tag = "6")]
        pub write_resource: u64,
        #[prost(uint64, required, tag = "7")]
        pub write_table_item: u64,
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Payload {
        #[prost(string, optional, tag = "2")]
        pub function: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "3")]
        pub type_arguments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "4")]
        pub arguments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "5")]
        pub execute_as: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "6")]
        pub entry_function_id_str: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        #[prost(message, optional, tag = "7")]
        pub code: ::core::option::Option<payload::Code>,
        #[prost(string, optional, tag = "8")]
        pub multisig_address: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `Payload`.
    pub mod payload {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Code {
            #[prost(string, required, tag = "1")]
            pub bytecode: ::prost::alloc::string::String,
            #[prost(message, required, tag = "2")]
            pub abi: super::super::super::modules::module::ExposedFunction,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TxPayload {
            #[prost(string, required, tag = "1")]
            pub function: ::prost::alloc::string::String,
            #[prost(string, repeated, tag = "2")]
            pub type_arguments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            #[prost(string, repeated, tag = "3")]
            pub arguments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        #[derive(serde::Serialize, serde::Deserialize)]
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Module {
            #[prost(string, required, tag = "1")]
            pub address: ::prost::alloc::string::String,
            #[prost(string, required, tag = "2")]
            pub name: ::prost::alloc::string::String,
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TxType {
        User = 1,
        Genesis = 2,
        BlockMetadata = 3,
        StateCheckpoint = 4,
        Validator = 5,
        BlockEpilogue = 6,
    }
    impl TxType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TxType::User => "user",
                TxType::Genesis => "genesis",
                TxType::BlockMetadata => "block_metadata",
                TxType::StateCheckpoint => "state_checkpoint",
                TxType::Validator => "validator",
                TxType::BlockEpilogue => "block_epilogue",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "user" => Some(Self::User),
                "genesis" => Some(Self::Genesis),
                "block_metadata" => Some(Self::BlockMetadata),
                "state_checkpoint" => Some(Self::StateCheckpoint),
                "validator" => Some(Self::Validator),
                "block_epilogue" => Some(Self::BlockEpilogue),
                _ => None,
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PayloadType {
        EntryFunction = 1,
        Script = 2,
        ModuleBundle = 3,
        Multisig = 4,
        Writeset = 5,
        GenesisWriteset = 6,
    }
    impl PayloadType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PayloadType::EntryFunction => "entry_function",
                PayloadType::Script => "script",
                PayloadType::ModuleBundle => "module_bundle",
                PayloadType::Multisig => "multisig",
                PayloadType::Writeset => "writeset",
                PayloadType::GenesisWriteset => "genesis_writeset",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "entry_function" => Some(Self::EntryFunction),
                "script" => Some(Self::Script),
                "module_bundle" => Some(Self::ModuleBundle),
                "multisig" => Some(Self::Multisig),
                "writeset" => Some(Self::Writeset),
                "genesis_writeset" => Some(Self::GenesisWriteset),
                _ => None,
            }
        }
    }
}
