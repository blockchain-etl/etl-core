// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Signature {
    #[prost(int64, required, tag = "1")]
    pub block_height: i64,
    #[prost(string, required, tag = "2")]
    pub block_timestamp: ::prost::alloc::string::String,
    #[prost(uint64, required, tag = "3")]
    pub tx_version: u64,
    #[prost(string, required, tag = "4")]
    pub tx_hash: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "5")]
    pub threshold: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "6")]
    pub is_secondary: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub is_fee_payer: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "8")]
    pub is_sender: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "9")]
    pub signature: ::core::option::Option<signature::Signature>,
    #[prost(message, required, tag = "10")]
    pub public_key: signature::PublicKey,
    #[prost(string, required, tag = "11")]
    pub build_type: ::prost::alloc::string::String,
    #[prost(string, required, tag = "12")]
    pub signer: ::prost::alloc::string::String,
    #[prost(message, required, tag = "13")]
    pub block_unixtimestamp: super::common::UnixTimestamp,
}
/// Nested message and enum types in `Signature`.
pub mod signature {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PublicKey {
        #[prost(string, required, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
        #[prost(string, required, tag = "2")]
        pub value: ::prost::alloc::string::String,
        #[prost(uint32, optional, tag = "3")]
        pub index: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `PublicKey`.
    pub mod public_key {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PublicKeyType {
            Unspecified = 1,
            Ed25519 = 2,
            Secp256k1Ecdsa = 3,
            Secp256r1Ecdsa = 4,
            Keyless = 5,
        }
        impl PublicKeyType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    PublicKeyType::Unspecified => "unspecified",
                    PublicKeyType::Ed25519 => "ed25519",
                    PublicKeyType::Secp256k1Ecdsa => "secp256k1_ecdsa",
                    PublicKeyType::Secp256r1Ecdsa => "secp256r1_ecdsa",
                    PublicKeyType::Keyless => "keyless",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "unspecified" => Some(Self::Unspecified),
                    "ed25519" => Some(Self::Ed25519),
                    "secp256k1_ecdsa" => Some(Self::Secp256k1Ecdsa),
                    "secp256r1_ecdsa" => Some(Self::Secp256r1Ecdsa),
                    "keyless" => Some(Self::Keyless),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Signature {
        #[prost(string, required, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
        #[prost(string, required, tag = "2")]
        pub value: ::prost::alloc::string::String,
        #[prost(uint32, optional, tag = "3")]
        pub index: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `Signature`.
    pub mod signature {
        #[derive(serde::Serialize, serde::Deserialize)]
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SignatureType {
            Unspecified = 1,
            Ed25519 = 2,
            Secp256k1Ecdsa = 3,
            Webauthn = 4,
            Zkid = 5,
            Keyless = 6,
        }
        impl SignatureType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    SignatureType::Unspecified => "unspecified",
                    SignatureType::Ed25519 => "ed25519",
                    SignatureType::Secp256k1Ecdsa => "secp256k1_ecdsa",
                    SignatureType::Webauthn => "webauthn",
                    SignatureType::Zkid => "zkid",
                    SignatureType::Keyless => "keyless",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "unspecified" => Some(Self::Unspecified),
                    "ed25519" => Some(Self::Ed25519),
                    "secp256k1_ecdsa" => Some(Self::Secp256k1Ecdsa),
                    "webauthn" => Some(Self::Webauthn),
                    "zkid" => Some(Self::Zkid),
                    "keyless" => Some(Self::Keyless),
                    _ => None,
                }
            }
        }
    }
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SignatureBuildType {
        Ed25519 = 1,
        MultiEd25519 = 2,
        MultiAgent = 3,
        FeePayer = 4,
        SingleSender = 5,
    }
    impl SignatureBuildType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SignatureBuildType::Ed25519 => "ed25519",
                SignatureBuildType::MultiEd25519 => "multi_ed25519",
                SignatureBuildType::MultiAgent => "multi_agent",
                SignatureBuildType::FeePayer => "fee_payer",
                SignatureBuildType::SingleSender => "single_sender",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ed25519" => Some(Self::Ed25519),
                "multi_ed25519" => Some(Self::MultiEd25519),
                "multi_agent" => Some(Self::MultiAgent),
                "fee_payer" => Some(Self::FeePayer),
                "single_sender" => Some(Self::SingleSender),
                _ => None,
            }
        }
    }
}
